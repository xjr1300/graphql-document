# グローバルオブジェクトの識別

<https://graphql.org/learn/global-object-identification/>

- [グローバルオブジェクトの識別](#グローバルオブジェクトの識別)
  - [仕様](#仕様)
  - [リザーブドタイプ（予約型）](#リザーブドタイプ予約型)
  - [Nodeインターフェイス](#nodeインターフェイス)
    - [イントロスペクション](#イントロスペクション)
  - [Nodeルートフィールド](#nodeルートフィールド)
    - [イントロスペクション](#イントロスペクション-1)
  - [フィールドの安定性](#フィールドの安定性)
  - [複数を識別するルートフィールド](#複数を識別するルートフィールド)
  - [フィールド](#フィールド)

> 一貫性のあるオブジェクトのアクセスは、単純なキャッシングとオブジェクトの検索を有効にします。

キャッシングとデータ取得を優雅に処理するオプションをGraphQLクライアントに提供するために、GraphQLサーバーが、標準化された方法でオブジェクトの識別子を公開する必要があります。

これを機能させるために、クライアントはIDによってオブジェクトをリクエストするために、標準的な機構を介してクエリする必要があります。
そして、レスポンスにおいて、スキーマはこれらのIDを提供する標準的な方法を提供する必要があります。

オブジェクトのIDよりも以外について少ししか知らないため、これらのオブジェクトを`ノード`と呼びます。
個々に、ノードをクエリする例を示します。

```graphql
{
  node(id: "4") {
    id
    ... on User {
      name
    }
  }
}
```

- GraphQLスキーマは、ルートクエリオブジェクトの`node`フィールドを介して、任意のオブジェクトを取得できるようにフォーマットされます。
  これは、`Node`インターフェイスに準拠したオブジェクトを返します。
- `id`フィールドは安全にレスポンスの外に抽出できて、キャッシングや再取得で再利用するために保存されます。
- クライアントは、その型特有の追加的な情報を抽出するためにインターフェイスフラグメントを使用できます。追加的な情報はノードインターフェイスに準拠しています。
  この場合、`User`です。

ノードインターフェイスは次のようになります。

```graphql
# オブジェクトのグローバルで一意のID
interface Node {
  # オブジェクトのID
  id: ID!
}
```

ユーザーを準拠させます。

```graphql
type User implements Node {
  id: ID!
  # フルネーム
  name: String!
}
```

## 仕様

次に説明するすべては、サーバーの実装間で一貫性を保証するために、オブジェクトの識別子に関するより正式な要求仕様です。
これらの仕様は、サーバーが[Relay](https://facebook.github.io/relay/)のAPIクライアントに準拠する方法に基づいていますが、どのクライアントにとっても役に立ちます。

## リザーブドタイプ（予約型）

GraphQLサーバーは、一貫性のあるオブジェクト識別子モデルをサポートするために、ある型と型の名前を予約する必要があります。特に、この仕様は次の型のガイドラインを作成しています。

- `Node`と名付けられたインターフェイス
- ルートクエリタイプの`node`フィールド

## Nodeインターフェイス

サーバーは`Node`と呼ばれるインターフェイスを提供する必要があります。
このインターフェイスは、非nullな`ID`を返す`id`と呼ばれる正確に1つのフィールドを含めなくてはなりません。

この`id`はこのオブジェクトにとってグローバルに一意な識別子である必要があり、単にこの`id`を与えると、サーバーはオブジェクトを取得できるべきです。

### イントロスペクション

上位のインターフェイスを正しく実装したサーバーは、次のイントロスペクションクエリを受け付け、提供されたレスポンスを返します。

```graphql
{
  __type(name: "Node") {
    name
    kind
    fields {
      name
      type {
        kind
        ofType {
          name
          kind
        }
      }
    }
  }
}
```

次を生み出します。

```json
{
  "__type": {
    "name": "Node",
    "kind": "INTERFACE",
    "fields": [
      {
        "name": "id",
        "type": {
          "kind": "NON_NULL",
          "ofType": {
            "name": "ID",
            "kind": "SCALAR"
          }
        }
      }
    ]
  }
}
```

## Nodeルートフィールド

サーバーは、`Node`インターフェイスを返す`node`と呼ばれるルートフィールドを提供しなければなりません。
このルートフィールドは、`id`と名付けられた非nullなIDで正確に1つの引数を受け取らなければなりません。

クエリが`Node`を実装したオブジェクトを返す場合、サーバーによって返された`Node`の`id`フィールド内の値が、`node`ルートフィールドに`id`パラメーターとして渡されたとき、このルートフィールドは同一のオブジェクトを取得するべきです。

サーバーは、最善を尽くしてこのデータを取得しなければなりませんが、それは常に可能であるわけではありません。
例えば、サーバーが有効な`id`を持つ`User`を返すかもしれませんが、リクエストが`node`ルートフィールドでそのユーザーを再取得するために作成さたとき、ユーザーのデータベースは利用不可能になっているかもしれませんし、またユーザーがそれらのアカウントを削除したかもしれません。
この場合、このフィールドをクエリした結果は、`null`になるべきです。

### イントロスペクション

上記要求を正しく実装したサーバーは、次のイントロスペクションクエリを受け付けて、提供されたレスポンスを含むレスポンスを返します。

```graphql
{
  __schema {
    queryType {
      fields {
        name
        type {
          name
          kind
        }
        args {
          name
          type {
            kind
            ofType {
              name
              kind
            }
          }
        }
      }
    }
  }
}
```

次が生み出されます。

```json
{
  "__schema": {
    "queryType": {
      "fields": [
        // この配列は他のエンティティを持つかもしれません。
        {
          "name": "node",
          "type": {
            "name": "Node",
            "kind": "INTERFACE"
          },
          "args": [
            {
              "name": "id",
              "type": {
                "kind": "NON_NULL",
                "ofType": {
                  "name": "ID",
                  "kind": "SCALAR"
                }
              }
            }
          ]
        }
      ]
    }
  }
}
```

## フィールドの安定性

クエリ内に、両方とも識別子となるIDを持つ`Node`を実装した2つのオブジェクトが現れたとき、2つのオブジェクトは等しくなければなりません。

この定義の目的のために、次の通りオブジェクトの等価性は定義されます。

- 2つのオブジェクトにフィールドをがクエリされた場合、最初のオブジェクトのフィールドのクエリの結果は、2番目のオブジェクトのフィールドをクエリした結果と等しくならなければなりません。
  - フィールドがスカラーを返す場合、等価性はそのスカラーとして適切に定義されます。
  - フィールドが列挙型を返す場合、等価性は両方のフィールドが同じ列挙型の値を返したかで定義されます。
  - フィールドがオブジェクトを返した場合、上記の通り再帰的に定義されます。

例えば・・・

```graphql
{
  fourNode: node(id: "4") {
    id
    ... on User {
      name
      userWithIdOneGreater {
        id
        name
      }
    }
  }
  fiveNode: node(id: "5") {
    id
    ... on User {
      name
      userWithIdOneLess {
        id
        name
      }
    }
  }
}
```

次を返すかもしれません。

```json
{
  "fourNode": {
    "id": "4",
    "name": "Mark Zuckerberg",
    "userWithIdOneGreater": {
      "id": "5",
      "name": "Chris Hughes"
    }
  },
  "fiveNode": {
    "id": "5",
    "name": "Chris Hughes",
    "userWithIdOneLess": {
      "id": "4",
      "name": "Mark Zuckerberg"
    }
  }
}
```

`fourNode.id`と`fiveNode.userWithIdOneLess.id`が同じなため、上記の条件を保証するために、`fourNode.name`は`fiveNode.userWithIdOneLess.name`と同じにならなければならず、それは確かにその様になっています。

## 複数を識別するルートフィールド

`username`と名付けられたルートフィールドを想像してください。
それはユーザー名を受け取り、対応するユーザーを返します。

```graphql
{
  username(username: "zuck") {
    id
  }
}
```

次を返すかもしれません。

```json
{
  "username": {
    "id": "4"
  }
}
```

明確にするために、レスポンス内でオブジェクトをつなぐことができ、IDに4を持つユーザーは、そのリクエストでは、ユーザー名に"zuck"を持つオブジェクトに識別されます。
ここで、`username`と名付けられたルートフィールドを想像して、それがユーザー名のリストを受け取り、オブジェクトのリストを返します。

```graphql
{
  usernames(usernames: ["zuck", "moskov"]) {
    id
  }
}
```

次を返すかもしれません。

```json
{
  "usernames": [
    {
      "id": "4"
    },
    {
      "id": "6"
    }
  ]
}
```

クライアントのために、ユーザー名とレスポンスをリンクすることができ、それはレスポンス内の配列が、引数として渡した配列と同じサイズで、レスポンス内の順番は、引数の順番とマッチする必要があります。
これらを*複数識別ルートフィールド*と呼び、次にそれらの要求事項を記述します。

## フィールド

この仕様に準拠するサーバーは、入力引数のリストを受け付けるルートフィールドを公開して、リストのレスポンスを返します。
これらのフィールドを使用する仕様に準拠したクライアントのために、これらのフィールドは*複数識別ルートフィールド*で、次の要求に従わなければなりません。

*複数識別ルートフィールド*は、単一の引数を持たなければなりません。
その引数の型は、非nullな（要素を持つ）非nullのリストでなければなりません。
`usernames`の例において、そのフィールドは`usernames`と名付けられた単一の引数を受け取り、その型は型システムの短縮表記を使用して`[String!]!`です。

*複数識別ルートフィールド*の戻り値の型はリスト、またはリストをラップした非nullでなくてはなりません。
そのリストは`Node`インターフェイスをラップして、`Node`インターフェイスを実装したオブジェクト、またはそれらの型をラップした非nullでなくてはなりません。

*複数識別ルートフィールド*が使用されるときはいつでも、レスポンスのリストの長さは引数内のリストの長さと同じでなくてはなりません。
レスポンス内のそれぞれのアイテムは、入力のそのアイテムと対応しなければなりません。
より正式に、入力リスト`Lin`をルートフィールドに渡したときの出力値が`Lout`の場合、任意の順列`P`に対して、`P(Lin)`をルートフィールドに渡すことは、出力値が`P(Lout)`にならなければなりません。

このため、サーバーはレスポンスタイプを非nullラッパーでラップしないようにすることをお勧めします。
これは、入力で与えたエントリのオブジェクトを取得できない場合、その入力エントリの出力に値を提供する必要があるためです。
nullは、そのための便利な値です。
