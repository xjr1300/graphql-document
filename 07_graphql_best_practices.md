# GraphQLのベストプラクティス

<https://graphql.org/learn/best-practices/>

- [GraphQLのベストプラクティス](#graphqlのベストプラクティス)
  - [HTTP](#http)
  - [JSON（GZIPで圧縮した）](#jsongzipで圧縮した)
  - [バージョニング](#バージョニング)
  - [null許可](#null許可)
  - [ページネーション](#ページネーション)
  - [サーバー側のバッチとキャッシュ](#サーバー側のバッチとキャッシュ)

GraphQL仕様は、ネットワーク、承認、ページネーションの処理など、APIが直面するいくつかの重要な問題について意図的に沈黙しています。
これは、GraphQLを使用したときにこれらの問題の解決がないことを意味せず、それらがGraphQLの説明の外部で、代わりに単なる一般的なプラクティスだからです。

このセクションの記事は、複音（良い知らせ）として取られるべきでなく、いくつかの場面では、他のアプローチを好み、当然無視されるかもしれません。
いくつかの記事は、GraphQLサービスの設計とデプロイに関してFacebook内で開発された哲学の一部を紹介していますが、他の記事では、HTTP経由でのサービスの提供や承認の実行などの一般的な問題を解決するためのより戦術的な提案をしています。

次は、より一般的なベストプラクティスとGraphQLサービスにより保持された独自の心構えについていくつかを簡単に説明しますが、このセクションそれぞれの記事で、これらと他のトピックについて詳しく説明します。

## HTTP

GraphQLは、典型的にサービスの機能の完全な集合を表現した単一のエンドポイントを経由したHTTPで提供されます。
これは、単一のリソースをそれぞれ公開する一連のURLを公開するREST APIとは対象的です。
GraphQLは、一連のリソースURLといっしょに使用できる一方で、これは[GraphiQL](https://github.com/graphql/graphiql)のようなツールで使用することを難しくする可能性があります。

これについての詳細は[HTTP経由でサービスする](https://graphql.org/learn/serving-over-http/)を読んでください。

## JSON（GZIPで圧縮した）

GraphQLサービスは、一般的にJSONを使用して応答しますが、GraphQL仕様は[それを要求していません](http://spec.graphql.org/draft/#sec-Serialization-Format)。
JSONはよりネットワーク性能を約束するAPIレイヤとして奇妙な選択に見えるかもしれませんが、それはほとんどテキストであり、それはGZIPで例外的に十分圧縮されます。

それは、すべてのGraphQLサービス製品がGZIPを有効にして、それらのクライアントにヘッダーを送信することが推奨されます。

```text
Accept-Encoding: gzip
```

JSONはクライアントとAPI開発者が慣れており、読むことやデバッグが簡単です。
実際、GraphQL構文は部分的にJSON構文に刺激を受けています。

## バージョニング

他のREST APIと同様に、GraphQLサービスのバージョン管理を妨げるものはありませんが、GraphQLは、GraphQLスキーマを継続的に進化させるツールを提供することで、バージョン管理を回避する強い見解があります。

なぜほとんどAPIはバージョンするのでしょうか？
APIエンドポイントから返されたデータの制御に制限があるとき、*任意の変更*は破壊的な変更と考えられる可能性があり、破壊的変更は新しいバーションを要求します。
もし、APIに新しい機能を追加するために新しいバージョンが要求される場合、頻繁にリリースすることと、多くの増加するバージョンを持つことと、APIの理解性と保守性の間でトレードオフが発生します。

対照的に、GraphQLは明示的に要求されたデータを返すのみで、破壊的変更を作成しないで、新しい型と新しいフィールドを介して新しい機能を追加できます。
これは、常に破壊的変更を避け、バージョンのないAPIを提供する一般的なプラクティスを導きます。

## null許可

"null"を認識するほとんどの型システムは、一般的な方とその型の*null許可*バージョンの両方を提供して、これにより明示的に宣言されない限りデフォルトの型はで"null"を含みません。
しかし、GraphQLの型システムにおいて、すべてのフィールドはデフォルトで*null許可*です。
この理由は、データベースと他のサービスに支えられたネットワークサービスにおいて、誤るたくさんのことがあるからです。
データベースはダウンする可能性があり、非同期アクションは失敗する可能性があり、例外はスローされる可能性があります。
単純なシステム障害を超えて、認可は細分化でき、リクエスト内の個々のフィールドは異なる認可ルールを持つことができます。

すべてのフィールドを*null許可*することをデフォルトにすることで、これらの理由でリクエストが完全に失敗するのではなく、そのフィールドだけが"null"として返される可能性があります。
代わりに、GraphQLは方の[非NULL](https://graphql.org/learn/schema/#lists-and-non-null)を提供して、もしリクエストしたとき、そのフィールドが決して"null"を返さないことをクライアントに保証します。
代わりに、もしエラーが発生した場合、前の親フィールドが変わりに"null"になります。

GraphQLスキーマを設計しているとき、誤る可能性があるすべての問題と、失敗したフィールドにとって"null"が適切な値であるかを念頭に置くことが重要です。
通常そうですが、たまにそうでなくなります。
そのような場面では、保証するために非NULL型を使用してください。

## ページネーション

GraphQLの型システムでは、一部のフィールドで値のリストを返すことができますが、値の長いリストのページネーションはAPI設計者に任せています。
ページネーションにはさまざまなAPI設計が可能ですが、それぞれに長所と短所があります。

通常、長いリストを返す可能性があるフィールドは、"first"と"after"引数を受け取り、リストの特定の領域を指定することができます。
"after"はリストのそれぞれの値のユニークな識別子です。

ページネーションの豪華な機能をもつ究極的なAPI設計は、"コネクション"と呼ばれるベストプラクティスなパターンを導きます。
[Relay](https://facebook.github.io/relay/)のようなGraphQLのいくつかのクライントツールは、GraphQL APIがこのパターンを採用しているとき、コネクションパターンを理解しており、自動的にクライアント側のページネーションのサポートを提供しています。

これについての詳細は[ページネーション](https://graphql.org/learn/pagination/)の記事を読んでください。

## サーバー側のバッチとキャッシュ

GraphQLはサーバーのきれいなコードを記述させる方法で設計されており、すべての型のすべてのフィールドは値を解決する単一目的の関数を持っています。
しかし、追加の考慮無しで、単純なGraphQLサービスはとても"おしゃべり"になるか、データベースから繰り返しデータをロードする可能性があります。

これの一般的な解決は、バッチ技術によるもので、バックエンドからのデータを要求する複数のリクエストが短期間に収集され、Facebookの[DataLoader](https://github.com/facebook/dataloader)などのツールを使用して、基盤となるデータベースまたはマイクロサービスに単一のリクエストで送信されます。
